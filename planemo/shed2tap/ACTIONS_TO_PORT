setup_ruby_environment

            # for ruby_package_tup in ruby_package_tups:
            #     gem, gem_version = ruby_package_tup
            #     if os.path.isfile( gem ):
            #         # we assume a local shipped gem file
            #         cmd = '''PATH=$PATH:$RUBY_HOME/bin; export PATH; GEM_HOME=$INSTALL_DIR; export GEM_HOME;
            #                 gem install --local %s''' % ( gem )
            #     elif gem.find( '://' ) != -1:
            #         # We assume a URL to a gem file.
            #         url = gem
            #         gem_name = url.split( '/' )[ -1 ]
            #         self.url_download( work_dir, gem_name, url, extract=False )
            #         cmd = '''PATH=$PATH:$RUBY_HOME/bin; export PATH; GEM_HOME=$INSTALL_DIR; export GEM_HOME;
            #                 gem install --local %s ''' % ( gem_name )
            #     else:
            #         # gem file from rubygems.org with or without version number
            #         if gem_version:
            #             # Specific ruby gem version was requested.
            #             # Use raw strings so that python won't automatically unescape the quotes before passing the command
            #             # to subprocess.Popen.
            #             cmd = r'''PATH=$PATH:$RUBY_HOME/bin; export PATH; GEM_HOME=$INSTALL_DIR; export GEM_HOME;
            #                 gem install %s --version "=%s"''' % ( gem, gem_version)
            #         else:
            #             # no version number given
            #             cmd = '''PATH=$PATH:$RUBY_HOME/bin; export PATH; GEM_HOME=$INSTALL_DIR; export GEM_HOME;
            #                 gem install %s''' % ( gem )

            # env_file_builder.append_line( name="GEM_PATH",
            #                               action="prepend_to",
            #                               value=install_environment.install_dir )
            # env_file_builder.append_line( name="PATH",
            #                               action="prepend_to",
            #                               value=os.path.join( install_environment.install_dir, 'bin' ) )

setup_python_environment

            # python_package_tups = action_dict.get( 'python_package_tups', [] )
            # for python_package_tup in python_package_tups:
            #     package, package_version = python_package_tup
            #     package_path = os.path.join( install_environment.tool_shed_repository_install_dir, package )
            #     if os.path.isfile( package_path ):
            #         # we assume a local shipped python package

            #         cmd = r'''PATH=$PATH:$PYTHONHOME/bin; export PATH;
            #                 export PYTHONPATH=$PYTHONPATH:$INSTALL_DIR;
            #                 easy_install --no-deps --install-dir $INSTALL_DIR --script-dir $INSTALL_DIR/bin %s
            #         ''' % ( package_path )
            #     elif package.find( '://' ) != -1:
            #         # We assume a URL to a python package.
            #         url = package
            #         package_name = url.split( '/' )[ -1 ]
            #         self.url_download( work_dir, package_name, url, extract=False )

            #         cmd = r'''PATH=$PATH:$PYTHONHOME/bin; export PATH;
            #                 export PYTHONPATH=$PYTHONPATH:$INSTALL_DIR;
            #                 easy_install --no-deps --install-dir $INSTALL_DIR --script-dir $INSTALL_DIR/bin %s
            #             ''' % ( package_name )
            #     else:
            #         pass
            #         # pypi can be implemented or for > python3.4 we can use the build-in system
            #     cmd = install_environment.build_command( basic_util.evaluate_template( cmd, install_environment ) )
            #     return_code = install_environment.handle_command( tool_dependency=tool_dependency,
            #                                                       cmd=cmd,
            #                                                       return_output=False )
            #     if return_code:
            #         if initial_download:
            #             return tool_dependency, filtered_actions, dir
            #         return tool_dependency, None, None
            # # Pull in python dependencies (runtime).
            # env_file_builder.handle_action_shell_file_paths( action_dict )
            # env_file_builder.append_line( name="PYTHONPATH",
            #                               action="prepend_to",
            #                               value= os.path.join( install_environment.install_dir, 'lib', 'python') )
            # env_file_builder.append_line( name="PATH",
            #                               action="prepend_to",
            #                               value=os.path.join( install_environment.install_dir, 'bin' ) )

setup_r_environment

            # for tarball_name in tarball_names:
            #     # Use raw strings so that python won't automatically unescape the quotes before passing the command
            #     # to subprocess.Popen.
            #     cmd = r'''PATH=$PATH:$R_HOME/bin; export PATH; R_LIBS=$INSTALL_DIR; export R_LIBS;
            #         Rscript -e "install.packages(c('%s'),lib='$INSTALL_DIR', repos=NULL, dependencies=FALSE)"''' % \
            #         ( str( tarball_name ) )
            #     cmd = install_environment.build_command( basic_util.evaluate_template( cmd, install_environment ) )
            #     return_code = install_environment.handle_command( tool_dependency=tool_dependency,
            #                                                       cmd=cmd,
            #                                                       return_output=False )
            #     if return_code:
            #         if initial_download:
            #             return tool_dependency, filtered_actions, dir
            #         return tool_dependency, None, None
            # # R libraries are installed to $INSTALL_DIR (install_dir), we now set the R_LIBS path to that directory
            # # Pull in R environment (runtime).
            # env_file_builder.handle_action_shell_file_paths( action_dict )
            # env_file_builder.append_line( name="R_LIBS", action="prepend_to", value=install_environment.install_dir )


setup_virtualenv

            #             python_cmd = action_dict[ 'python' ]
            # # TODO: Consider making --no-site-packages optional.
            # setup_command = "%s %s/virtualenv.py --no-site-packages '%s'" % ( python_cmd, venv_src_directory, venv_directory )
            # # POSIXLY_CORRECT forces shell commands . and source to have the same
            # # and well defined behavior in bash/zsh.
            # activate_command = "POSIXLY_CORRECT=1; . %s" % os.path.join( venv_directory, "bin", "activate" )
            # if action_dict[ 'use_requirements_file' ]:
            #     install_command = "python '%s' install -r '%s' --log '%s'" % \
            #         ( os.path.join( venv_directory, "bin", "pip" ),
            #           requirements_path,
            #           os.path.join( install_environment.install_dir, 'pip_install.log' ) )
            # else:
            #     install_command = ''
            #     with open( requirements_path, "rb" ) as f:
            #         while True:
            #             line = f.readline()
            #             if not line:
            #                 break
            #             line = line.strip()
            #             if line:
            #                 line_install_command = "python '%s' install %s --log '%s'" % \
            #                     ( os.path.join( venv_directory, "bin", "pip" ),
            #                       line,
            #                       os.path.join( install_environment.install_dir, 'pip_install_%s.log' % ( line ) ) )
            #                 if not install_command:
            #                     install_command = line_install_command
            #                 else:
            #                     install_command = "%s && %s" % ( install_command, line_install_command )
            # full_setup_command = "%s; %s; %s" % ( setup_command, activate_command, install_command )
            # return_code = install_environment.handle_command( tool_dependency=tool_dependency,
            #                                                   cmd=full_setup_command,
            #                                                   return_output=False )

setup_perl_environment

            # cmd = '''PERL_MM_USE_DEFAULT=1; export PERL_MM_USE_DEFAULT; '''
            # cmd += 'export PERL5LIB=$INSTALL_DIR/lib/perl5:$PERL5LIB;'
            # cmd += 'export PATH=$INSTALL_DIR/bin:$PATH;'
            # dir = self.url_download( work_dir, perl_package_name, url, extract=True )
            # if perl_package.find( '://' ) != -1:
            #                         if os.path.exists( os.path.join( tmp_work_dir, 'Makefile.PL' ) ):
            # cmd += '''perl Makefile.PL INSTALL_BASE=$INSTALL_DIR && make && make install'''
            #             elif os.path.exists( os.path.join( tmp_work_dir, 'Build.PL' ) ):
            #             cmd += '''perl Build.PL --install_base $INSTALL_DIR && perl Build && perl Build install'''
            #  else
            # cmd += '''cpanm --local-lib=$INSTALL_DIR %s''' % ( perl_package )
            # cmd = install_environment.build_command( basic_util.evaluate_template( cmd, install_environment ) )
